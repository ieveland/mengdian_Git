//eg.二分搜索
int search(int* nums,int numsSize,int target){
  for(int i=0;i<numsSize;i++)
    if(nums[i]==target)return i;
  return -1;
}//直接遍历
int BinarySearch(int* nums,int target,int left,int right){
  if(left>right)return -1;//特例1
  int mid=(left+right)/2;//特例2
  if(nums[mid]==target)return mid;
  if(nums[mid]<target)
    return BinarySearch(nums,target,mid+1,right);
  else 
    return BinarySearch(nums,target,left,mid-1);
}//log2(n)
--------------------------------------------------------------
//线性表
//初始化，获取元素，插入元素，删除元素，获取长度，进阶版数组；可顺序存储，可链式存储
typedef int E;
struct List{
  E * array;
  int capacity;//容量
  int size;//实际存储元素量
};
typedef struct List * ArrayList; 
bool initList(ArrayList list){
  list->array=(E*)malloc(sizeof(E)*10);//申请与容量对应的内存块
  if(list->array==NULL)return 0;//失败
  list->capacity=10;  
  list->size=0;
  return 1;
}
bool insertList(ArrayList list,E element,int index){
  if(index<1||index>list->size+1)return 0;//容量的事情不在这里考虑，这里只考虑要想插入数据，只可能在1到已有的最后一个数据的下一位这size+1的位置插入
  if(list->size==list->capacity){
    int newCapacity=list->capacity+(list->capacity>>1);
    E* newArray=(E*)realloc(list->array,newCapacity*sizeof(E));//原数组和新的大小
    if(newArray==NULL)return 0;//申请失败
    list->array=newArray;
    list->capacity=newCapacity;
  }//容量不足扩容使用，realloc可以申请新的内存并且把旧的数据一起复制到新内存
  for(int i=list->size;i>index-1;--i)//虽然index按序，但数组是按照0起始
    list->array[i]=list->array[i-1];
  list->array[index-1]=element;
  list->size++;
  return 1;
}//注意顺序表的index是按位计算从1开始,也就是我们常用的计数顺序
bool deleteList(ArrayList list,int index){
  if(index<1||index>list->size)return 0;
  for(int i=index-1;i<list->size-1;i++)
    list->array[i]=list->array[i+1];
  list->size--;
  return 1;
}
----------------------------------------------------------------
//链表
//不需要申请连续的空间，物理不相连，逻辑相连；带头结点的链表，不带头结点的链表
struct ListNode{
  E element;
  struct ListNode * next;
};
typedef struct ListNode * Node;
void initList(Node node){
  node->next=NULL;
}
bool insertList(Node head,E element,int index){
  if(index<1)return 0;
  while(--index){
    head=head->next;
    if(head==NULL)return 0;
  }//插入在index的位置
  Node node=malloc(sizeof(struct ListNode));
  if(node==NULL)return 0;
  node->element=element;
  node->next=head->next;
  head->next=node;  
  return 1;
}
