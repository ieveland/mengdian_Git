//线性表
-------------------------------------------------------------------
//eg.二分搜索
int search(int* nums,int numsSize,int target){
  for(int i=0;i<numsSize;i++)
    if(nums[i]==target)return i;
  return -1;
}//直接遍历
int BinarySearch(int* nums,int target,int left,int right){
  if(left>right)return -1;//特例1
  int mid=(left+right)/2;//特例2
  if(nums[mid]==target)return mid;
  if(nums[mid]<target)
    return BinarySearch(nums,target,mid+1,right);
  else 
    return BinarySearch(nums,target,left,mid-1);
}//log2(n)
-------------------------------------------------------------------
//顺序表
//初始化，获取元素，插入元素，删除元素，获取长度，进阶版数组；可顺序存储，可链式存储
typedef int E;
struct List{
  E * array;
  int capacity;//容量
  int size;//实际存储元素量
};
typedef struct List * ArrayList; 
bool initList(ArrayList list){
  list->array=(E*)malloc(sizeof(E)*10);//申请与容量对应的内存块
  if(list->array==NULL)return 0;//失败
  list->capacity=10;  
  list->size=0;
  return 1;
}
bool insertList(ArrayList list,E element,int index){
  if(index<1||index>list->size+1)return 0;//容量的事情不在这里考虑，这里只考虑要想插入数据，只可能在1到已有的最后一个数据的下一位这size+1的位置插入
  if(list->size==list->capacity){
    int newCapacity=list->capacity+(list->capacity>>1);
    E* newArray=(E*)realloc(list->array,newCapacity*sizeof(E));//原数组和新的大小
    if(newArray==NULL)return 0;//申请失败
    list->array=newArray;
    list->capacity=newCapacity;
  }//容量不足扩容使用，realloc可以申请新的内存并且把旧的数据一起复制到新内存
  for(int i=list->size;i>index-1;--i)//虽然index按序，但数组是按照0起始
    list->array[i]=list->array[i-1];
  list->array[index-1]=element;
  list->size++;
  return 1;
}//注意顺序表的index是按位计算从1开始,也就是我们常用的计数顺序
bool deleteList(ArrayList list,int index){
  if(index<1||index>list->size)return 0;
  for(int i=index-1;i<list->size-1;i++)
    list->array[i]=list->array[i+1];
  list->size--;
  return 1;
}
----------------------------------------------------------------
//链表
//表长未知（表长不包括头结点），不需要申请连续的空间，物理不相连，逻辑相连；带头结点的链表，不带头结点的链表
struct ListNode{
  E element;
  struct ListNode * next;
};
typedef struct ListNode * Node;
void initList(Node node){
  node->next=NULL;
}
bool insertList(Node head,E element,int index){//头结点不存数据
  if(index<1)return 0;
  while(--index){
    head=head->next;//把结点从头结点挪到index-1的位置
    if(head==NULL)return 0;//null就说明插入index位置超过已有链表长度了
  }//插入在index的位置
  Node node=malloc(sizeof(struct ListNode));
  if(node==NULL)return 0;
  node->element=element;
  node->next=head->next;
  head->next=node;
  return 1;
}
bool deleteList(Node head,int index){
  if(index<1)return 0;
  while(--index){
    head=head->next;
    if(head==NULL)return 0;
  }//因为这里到达的是index-1的位置
  if(head->next==NULL)return 0;//index的位置为空
  Node tmp=head->next;
  head->next=head->next->next;
  free(tmp);
  return 1;
}
//双向链表
struct ListNode{
  E element;
  struct ListNode * next;
  struct ListNode * prev;
};
typedef struct ListNode * Node;
void initList(Node node){
  node->next=node->prev=NULL;
}
bool insertList(Node head,E element,int index){
  if(index<1)return 0;
  while(--index){
    head=head->next;
    if(head==NULL)return 0;
  }
  Node node=malloc(sizeof(struct ListNode));
  if(node==NULL)return 0;
  node->element=element;
  if(head->next){是否插入尾部
    head->next->prev=node;
    node->next=head->next;
  }else{
    node->next=NULL;
  }
  head->next=node;
  node->prev=head;
  return 1;
}
bool deleteList(Node head,int index){
  if(index<1)return 0;
  while(--index){
    head=head->next;
    if(head==NULL)return 0;
  }
  if(head==NULL)return 0;
  Node tmp=head->next;
  if(head->next->next){
    head->next=head->next->next;  
    head->next->next->prev=head;
  }else{
    head->next=NULL;    
  }
  free(tmp);
  return 1;
}
--------------------------------------------------------------------
//栈FILO
//顺序表实现栈
struc Stack{
  E * array;
  int capacity;
  int top;//栈顶元素下标
};
typedef struct Stack * ArrayStack;
bool initStack(ArrayStack stack){
  stack->array=malloc(sizeof(E)*10);
  if(stack->array==NULL)return 0;
  stack->capacity=10;
  stack->top=-1;//0指的栈底元素
  return 1;
}
bool pushStack(ArrayStack stack,E element){
  if(stack->top==stack->capacity){//可扩容版本
    int newCapacity=stack->capacity+(stack->capacity>>1);
    E * newArray=realloc(stack->array,newCapacity*sizeof(E));
    if(newArray==NULL)return 0;
    stack->array=newArray;
    stack->capacity=newCapacity;
  }
  stack->array[stack->top+1]=element;
  stack->top++;
  return 1;
}
bool isEmpty(ArrayStack stack){
  return stack->top==-1;
}
E popStack(ArrayStack stack){
  return stack->array[stack->top--];  
}
//链表实现栈
